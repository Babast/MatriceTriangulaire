<!DOCTYPE html>
<html>
    <head>
        <title>MatriceTriangulaire</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
        <div>
            <input type="button" value="Animer!" onclick="RotationCam();">
        </div>
        <script type="text/javascript" src="js/libs/three.min.js"></script>      
        <script type="text/javascript" src="js/libs/TrackballControls.js"></script>
                
        <script>
            
    var container;
    var objects = [];
    var camera, scene, renderer, projector, controls;  
    var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;
    init();
    animate();
    
    function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true, clearColor: 0x000000, clearAlpha: 1 });
        renderer.setSize( window.innerWidth-50, window.innerHeight-50 );
	document.body.appendChild( renderer.domElement );

	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.y = 200;
        camera.position.z = 200;
        
        controls = new THREE.TrackballControls( camera );
        controls.rotateSpeed = 1.0;
	controls.zoomSpeed = 4;
	controls.panSpeed = 2;
	controls.noZoom = false;
	controls.noPan = false;
	controls.staticMoving = true;
	controls.dynamicDampingFactor = 0.3;
        
        scene = new THREE.Scene();
        
        //Horizontal Grid
        var lineH_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
                geometry = new THREE.Geometry(),
                floor = 0, step = 10;
        for ( var i = 0; i <= 40; i ++ ) {
            geometry.vertices.push( new THREE.Vector3( - 200, floor, i * step - 200 ) );
            geometry.vertices.push( new THREE.Vector3(   200, floor, i * step - 200 ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, floor, -200 ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, floor,  200 ) );
        }
        var line = new THREE.Line( geometry, lineH_material, THREE.LinePieces );
        scene.add( line );
        
        //Vertical Grid
        var lineV_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
                geometry = new THREE.Geometry(),
                floor = 0, step = 10;
        for ( var i = 0; i <= 40; i ++ ) {
            geometry.vertices.push( new THREE.Vector3( -200,  i * step , floor ) );
            geometry.vertices.push( new THREE.Vector3(200, i * step , floor   ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, floor, 0 ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, 400, 0 ) );
        }
        var line = new THREE.Line( geometry, lineV_material, THREE.LinePieces );
        scene.add( line );
        
        //Triangle base
        var triangle_material = new THREE.LineBasicMaterial( { color: 0x909090 } ),
                geometry = new THREE.Geometry(),
                floor = 0;
        geometry.vertices.push( new THREE.Vector3(-200, 0 , 0) );
        geometry.vertices.push( new THREE.Vector3( 200, 400, 0 ) );
        geometry.vertices.push( new THREE.Vector3( 200, 400, 0 ) );
        geometry.vertices.push( new THREE.Vector3(200, 0, 0 ) );
        geometry.vertices.push( new THREE.Vector3(200, 0, 0 ) );
        geometry.vertices.push( new THREE.Vector3(-200, 0, 0 ) );
        var line = new THREE.Line( geometry, triangle_material, THREE.LinePieces );
        scene.add( line );

        //Cube
        var geometry = new THREE.CubeGeometry( 50, 50, 50 );
        var texture = THREE.ImageUtils.loadTexture( 'crate.gif' );
        texture.anisotropy = renderer.getMaxAnisotropy();
	var material = new THREE.MeshBasicMaterial( { map: texture } );
	mesh = new THREE.Mesh( geometry, material );
	scene.add( mesh );
                
        rotation = false;
        
        //scene.position.y = 100;
        //camera.lookAt( scene.position );
                
        projector = new THREE.Projector();

        window.addEventListener( 'resize', onWindowResize, false );
        renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
	renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
	renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth-50, window.innerHeight-50 );
    }
    
    function animate() {
        requestAnimationFrame( animate );
        controls.update();
        if (rotation){
            var timer = 0.0005 * Date.now();
            camera.position.x = Math.cos( timer ) * 400;
            camera.position.z = Math.sin( timer ) * 200;
            camera.lookAt( scene.position );
        }
        renderer.render(scene, camera);
    }
    
    function RotationCam() {
        if(rotation){
            rotation = false;
        }
        else{
            rotation =true;
        }
    }
    
    function onDocumentMouseMove( event ) {
        event.preventDefault();
        
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
        var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	projector.unprojectVector( vector, camera );

	var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );


	if ( SELECTED ) {
            var intersects = raycaster.intersectObject( plane );
            SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
            return;
        }
        
        var intersects = raycaster.intersectObjects( objects );

	if ( intersects.length > 0 ) {
            if ( INTERSECTED !== intersects[ 0 ].object ) {
                if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                INTERSECTED = intersects[ 0 ].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

		plane.position.copy( INTERSECTED.position );
		plane.lookAt( camera.position );
            }
        } 
        else {
            if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
            INTERSECTED = null;
        }
    }
    
    function onDocumentMouseDown( event ) {
        event.preventDefault();
        var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
        projector.unprojectVector( vector, camera );
        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
        var intersects = raycaster.intersectObjects( objects );
        if ( intersects.length > 0 ) {
            controls.enabled = false;
            SELECTED = intersects[ 0 ].object;
            var intersects = raycaster.intersectObject( plane );
            offset.copy( intersects[ 0 ].point ).sub( plane.position );
        }
    }
    
    function onDocumentMouseUp( event ) {
        event.preventDefault();
        controls.enabled = true;
        if ( INTERSECTED ) {
            plane.position.copy( INTERSECTED.position );
            SELECTED = null;
        }
    }

        </script>
    </body>
</html>
