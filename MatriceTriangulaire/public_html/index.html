<!DOCTYPE html>
<html>
    <head>
        <title>MatriceTriangulaire</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body onkeyup="keyup(event);">
        <div>
            Matrice triangulaire 3d avec HTML5 & Three.js <br/>
            Appuyer sur la touche "M" pour activer/d√©sactiver les mouvements<br/>
            Click gauche: Avancer - Click droit: Reculer
        </div>
        <script type="text/javascript" src="js/libs/three.min.js"></script>      
        <script type="text/javascript" src="js/libs/FirstPersonControls.js"></script>
        <script>
            
    var container;
    var camera, scene, renderer, controls;  
    var clock = new THREE.Clock();
    var moving = false;
    var cubes= [];
    
    init();
    animate();
    
    function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true, clearColor: 0x000000, clearAlpha: 1 });
        renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.set( 0, 200, 500 );
        controls = new THREE.FirstPersonControls( camera );
        controls.movementSpeed = 30;
        controls.lookSpeed = 0.2;
        
        scene = new THREE.Scene();
        scene.position.set( 0, 200, 0 );
        camera.lookAt(scene.position);
        
        //Horizontal Grid
        var lineH_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
                geometry = new THREE.Geometry(),
                floor = 0, step = 10;
        for ( var i = 0; i <= 40; i ++ ) {
            geometry.vertices.push( new THREE.Vector3( - 200, floor, i * step - 200 ) );
            geometry.vertices.push( new THREE.Vector3(   200, floor, i * step - 200 ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, floor, -200 ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, floor,  200 ) );
        }
        var line = new THREE.Line( geometry, lineH_material, THREE.LinePieces );
        scene.add( line );
        
        //Vertical Grid
        var lineV_material = new THREE.LineBasicMaterial( { color: 0x303030 } ),
                geometry = new THREE.Geometry(),
                floor = 0, step = 10;
        for ( var i = 0; i <= 40; i ++ ) {
            geometry.vertices.push( new THREE.Vector3( -200,  i * step , floor ) );
            geometry.vertices.push( new THREE.Vector3(200, i * step , floor   ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, floor, 0 ) );
            geometry.vertices.push( new THREE.Vector3( i * step - 200, 400, 0 ) );
        }
        var line = new THREE.Line( geometry, lineV_material, THREE.LinePieces );
        scene.add( line );
        
        //Triangle base
        var triangle_material = new THREE.LineBasicMaterial( { color: 0x909090 } ),
                geometry = new THREE.Geometry();
        geometry.vertices.push( new THREE.Vector3(-200, 0 , 0) );
        geometry.vertices.push( new THREE.Vector3( 200, 400, 0 ) );
        geometry.vertices.push( new THREE.Vector3( 200, 400, 0 ) );
        geometry.vertices.push( new THREE.Vector3(200, 0, 0 ) );
        geometry.vertices.push( new THREE.Vector3(200, 0, 0 ) );
        geometry.vertices.push( new THREE.Vector3(-200, 0, 0 ) );
        var line = new THREE.Line( geometry, triangle_material, THREE.LinePieces );
        scene.add( line );

        //Cube
        var geometry = new THREE.CubeGeometry( 50, 50, 50 );
        var texture = THREE.ImageUtils.loadTexture( 'crate.gif' );
        texture.anisotropy = renderer.getMaxAnisotropy();
	var material = new THREE.MeshBasicMaterial( { map: texture } );
	mesh = new THREE.Mesh( geometry, material );
        mesh.position.y = 25;
	mesh.position.x = 100;
        mesh.position.z = 100;
        scene.add( mesh );
        cubes.push( mesh );
        
        rotation = false;

        window.addEventListener( 'resize', onWindowResize, false );

    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }
    
    function animate() {
        requestAnimationFrame( animate );
        if (cubes[0].position.y <= 400 && cubes[0].position.y >= 0){
             cubes[0].position.y += 1;
        }
        else{
            cubes[0].position.y -= 1;
        }
       cubes[0].rotation.x += 1;

        render();
    }
    
    function render() {
        if (moving){
               controls.update( clock.getDelta() );
            }
        renderer.render( scene, camera );
    }
    
    function keyup(ev) {
	if (ev.keyCode===77){ //M
            if (moving){
                moving = false;
            }
            else{
                moving = true;
            }
	}
    }
        </script>
    </body>
</html>
